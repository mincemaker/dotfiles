#!zsh
# __git_branch_switches
# _git-submodule

(( $+functions[_git-submodule] )) ||
_git-submodule () {
  local curcontext=$curcontext state line
  declare -A opt_args

  _arguments -C \
    '(-q --quiet)'{-q,--quiet}'[Only print error messages]' \
    ':command:->command' \
    '*::options:->options' && ret=0

  case $state in
    (command)
      declare -a commands

      commands=(
        'add:Add the given repository as a submodule at the given path to the changeset to be commtied next to the current project'
        'status:Show the status of the submodules'
        'init:Initialize the submodules'
        'update:Update the registred submodules'
        'summary:Show commit summary between the given commit and working tree/index'
        'foreach:Evaluates an arbitrary shell command in each checked out submodule'
        'sync:Synchronize submodules')
        _describe -t commands command commands && ret=0
      ;;
    (options)
      declare -a arguments

      if [[ $line[1] == (add) ]]; then
        arguments+=(
          '(-b --branch)'{-b,-branch}'[Branch of repository to add as submodule]:branch:__git_branch_names'
          '(-f --force)'{-f,--force}'[force overwrite of existing files]')
      fi

      if [[ $line[1] == (summary) ]]; then
        arguments+=(
          '--files[This command compares the commit in the index with that in the submodule HEAD when this iption is used]'
          '(-n --summary-limit)'{-n,--summary-limit}'[Limit the summary size]')
      fi

      if [[ $line[1] == (status|summary) ]]; then
        arguments+=(
          '--cached[the commit stored in the index is used instead]')
      fi

      if [[ $line[1] == (update) ]]; then
        arguments+=(
          '--merge[Merge the commit recorded in the superproject into the current branch of the submodule]'
          '--rebase[Rebase the current branch onto the commit recoreded in the superproject]'
          '--init[automatically initialize the submodule]'
          '(-N --no-fetch)'{-N,--no-fetch}'[Do not fetch new objects from the remote site]')
      fi

      if [[ $line[1] == (add|update) ]]; then
        arguments+=(
          '--reference[reference repository]:repository:_directories')
      fi

      if [[ $line[1] == (foreach|update|status) ]]; then
        arguments+=(
          '--recursive[Traverse submodules recursively]')
      fi

      case $line[1] in
        (add)
          arguments+=(':url:_urls')
          ;;
      esac

      arguments+=('::directory:_directories')

      _arguments -C \
        $arguments && ret=0

      case $state in
        (subdirectory)
          _alternative \
            'sub-directories:sub-directory:_directories' \
            'urls: :_urls' && ret=0
          ;;
      esac
      ;;
  esac
}
__git_revisions_fu () {
  __git_branch_switches
  __git_revisions
}
__git_branch_switches () {
  local expl gitdir
  typeset -a branch_switches

  gitdir=$(_call_program gitdir git rev-parse --git-dir 2>/dev/null)
  __git_command_successful || return
  [[ -f ${gitdir}/logs/HEAD ]] || return

  local sha1ish='????????????????????????????????????????'
  branch_switches=(${(Oau)${${${(M)${(@f)"$(<${gitdir}/logs/HEAD)"}:#*checkout: moving from *}#*checkout: moving from * to }:#${~sha1ish}}})

  local b=$(_call_program gitsymbolicref git symbolic-ref HEAD 2>/dev/null)
  __git_command_successful || return


  : ${(A)branch_switches::=${branch_switches:#${b##refs/heads/}}}

  _wanted -V branch-switches expl branch-switch compadd $* - $branch_switches
}

my__git_func_body () {
  local fname="$1"
  local place="$2"
  : ${(P)place::=${${functions[_git]##*${fname} \(\)}%%\(\( \$+functions*}}
}

my__git_initialize () {
  autoload +X _git

  # setting for checkout branch stack
  local code=''
  my__git_func_body git-checkout code
  eval "function _git-checkout () ${code//:__git_revisions/:__git_revisions_fu}"

  zstyle ':completion::complete:git:*' group-order branch-switches

  # setting for submodule
  eval "function _git () { ${functions[_git]/interoperability_commands=\(/interoperability_commands=('submodule:Initialize, update or inspect submodules' } }"
}
my__git_initialize

